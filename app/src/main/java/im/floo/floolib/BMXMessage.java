/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

package im.floo.floolib;

/**
 *  消息
 **/
public class BMXMessage extends BMXBaseObject {
  private transient long swigCPtr;
  private transient boolean swigCMemOwnDerived;

  protected BMXMessage(long cPtr, boolean cMemoryOwn) {
    super(flooJNI.BMXMessage_SWIGSmartPtrUpcast(cPtr), true);
    swigCMemOwnDerived = cMemoryOwn;
    swigCPtr = cPtr;
  }

  protected static long getCPtr(BMXMessage obj) {
    return (obj == null) ? 0 : obj.swigCPtr;
  }

  protected void finalize() {
    delete();
  }

  public synchronized void delete() {
    if (swigCPtr != 0) {
      if (swigCMemOwnDerived) {
        swigCMemOwnDerived = false;
        flooJNI.delete_BMXMessage(swigCPtr);
      }
      swigCPtr = 0;
    }
    super.delete();
  }

  /**
   *  消息唯一ID
   * @return int64_t
   **/
  public long msgId() {
    return flooJNI.BMXMessage_msgId(swigCPtr, this);
  }

  /**
   *  消息客户端ID,仅在消息发送端存在
   * @return int64_t
   **/
  public long clientMsgId() {
    return flooJNI.BMXMessage_clientMsgId(swigCPtr, this);
  }

  /**
   *  消息发送方ID
   * @return int64_t
   **/
  public long fromId() {
    return flooJNI.BMXMessage_fromId(swigCPtr, this);
  }

  /**
   *  消息接收方ID
   * @return int64_t
   */
  public long toId() {
    return flooJNI.BMXMessage_toId(swigCPtr, this);
  }

  /**
   *  消息类型
   * @return MessageType
   */
  public BMXMessage.MessageType type() {
    return BMXMessage.MessageType.swigToEnum(flooJNI.BMXMessage_type(swigCPtr, this));
  }

  /**
   *  消息所属会话ID
   * @return int64_t
   */
  public long conversationId() {
    return flooJNI.BMXMessage_conversationId(swigCPtr, this);
  }

  /**
   *  消息投递状态
   * @return DeliveryStatus
   */
  public BMXMessage.DeliveryStatus deliveryStatus() {
    return BMXMessage.DeliveryStatus.swigToEnum(flooJNI.BMXMessage_deliveryStatus(swigCPtr, this));
  }

  /**
   *  设置消息投递状态
   */
  public void setDeliveryStatus(BMXMessage.DeliveryStatus arg0) {
    flooJNI.BMXMessage_setDeliveryStatus(swigCPtr, this, arg0.swigValue());
  }

  /**
   *  消息时间戳（服务端收到时的时间）
   * @return int64_t
   */
  public long serverTimestamp() {
    return flooJNI.BMXMessage_serverTimestamp(swigCPtr, this);
  }

  /**
   *  设置时间戳（服务端收到时的时间）
   */
  public void setServerTimestamp(long arg0) {
    flooJNI.BMXMessage_setServerTimestamp(swigCPtr, this, arg0);
  }

  /**
   *  本地时间戳（消息创建或者收到时的本地时间）
   * @return int64_t
   */
  public long clientTimestamp() {
    return flooJNI.BMXMessage_clientTimestamp(swigCPtr, this);
  }

  /**
   *  设置消息本地时间戳
   */
  public void setClientTimestamp(long arg0) {
    flooJNI.BMXMessage_setClientTimestamp(swigCPtr, this, arg0);
  }

  /**
   *  语音或者视频消息是否播放过，仅对收到的音视频消息有效
   * @return bool
   */
  public boolean isPlayed() {
    return flooJNI.BMXMessage_isPlayed(swigCPtr, this);
  }

  public void setIsPlayed(boolean arg0) {
    flooJNI.BMXMessage_setIsPlayed(swigCPtr, this, arg0);
  }

  /**
   *  语音或者视频消息是否收到播放回执，仅对收到的音视频消息有效
   * @return bool
   */
  public boolean isPlayAcked() {
    return flooJNI.BMXMessage_isPlayAcked(swigCPtr, this);
  }

  public void setIsPlayAcked(boolean arg0) {
    flooJNI.BMXMessage_setIsPlayAcked(swigCPtr, this, arg0);
  }

  /**
   *  是否接收的消息
   * @return bool
   */
  public boolean isReceiveMsg() {
    return flooJNI.BMXMessage_isReceiveMsg(swigCPtr, this);
  }

  public void setIsReceiveMsg(boolean arg0) {
    flooJNI.BMXMessage_setIsReceiveMsg(swigCPtr, this, arg0);
  }

  /**
   *  消息是否已读标志
   * @return bool
   */
  public boolean isRead() {
    return flooJNI.BMXMessage_isRead(swigCPtr, this);
  }

  public void setIsRead(boolean arg0) {
    flooJNI.BMXMessage_setIsRead(swigCPtr, this, arg0);
  }

  /**
   *  对于发送方表示是否收到了已读回执，对于接收方表示是否发送了已读回执
   * @return bool
   */
  public boolean isReadAcked() {
    return flooJNI.BMXMessage_isReadAcked(swigCPtr, this);
  }

  public void setIsReadAcked(boolean arg0) {
    flooJNI.BMXMessage_setIsReadAcked(swigCPtr, this, arg0);
  }

  /**
   *  对于发送方表示消息是否已投递到对方，对于接收方表示是否发送了消息已到达回执
   * @return bool
   */
  public boolean isDeliveryAcked() {
    return flooJNI.BMXMessage_isDeliveryAcked(swigCPtr, this);
  }

  public void setIsDeliveryAcked(boolean arg0) {
    flooJNI.BMXMessage_setIsDeliveryAcked(swigCPtr, this, arg0);
  }

  /**
   *  消息文本内容
   * @return std::string
   */
  public String content() {
    return flooJNI.BMXMessage_content(swigCPtr, this);
  }

  /**
   *  消息文本内容
   * @param content 消息文本内容
   */
  public void setContent(String content) {
    flooJNI.BMXMessage_setContent(swigCPtr, this, content);
  }

  /**
   *  消息内容类型，如果带附件就表示附件类型，不带附件就是文本类型
   * @return ContentType
   */
  public BMXMessage.ContentType contentType() {
    return BMXMessage.ContentType.swigToEnum(flooJNI.BMXMessage_contentType(swigCPtr, this));
  }

  /**
   *  消息附件，BMXMessage拥有附件的所有权，负责释放
   * @return BMXMessageAttachmentPtr
   */
  public BMXMessageAttachment attachment() {
    long cPtr = flooJNI.BMXMessage_attachment(swigCPtr, this);
    return (cPtr == 0) ? null : new BMXMessageAttachment(cPtr, true);
  }

  /**
   *  消息的配置信息
   * @return JSON(std::string)
   */
  public BMXMessageConfig config() {
    long cPtr = flooJNI.BMXMessage_config(swigCPtr, this);
    return (cPtr == 0) ? null : new BMXMessageConfig(cPtr, true);
  }

  /**
   *  设置消息配置信息
   */
  public void setConfig(BMXMessageConfig arg0) {
    flooJNI.BMXMessage_setConfig(swigCPtr, this, BMXMessageConfig.getCPtr(arg0), arg0);
  }

  /**
   *  消息扩展信息
   * @return JSON(std::string)
   */
  public String extension() {
    return flooJNI.BMXMessage_extension(swigCPtr, this);
  }

  /**
   *  设置消息扩展信息
   */
  public void setExtension(String arg0) {
    flooJNI.BMXMessage_setExtension(swigCPtr, this, arg0);
  }

  /**
   *  消息投递QOS
   * @return DeliveryQos
   */
  public BMXMessage.DeliveryQos deliveryQos() {
    return BMXMessage.DeliveryQos.swigToEnum(flooJNI.BMXMessage_deliveryQos(swigCPtr, this));
  }

  /**
   *  设置消息投递QOS
   * @param qos 消息投递QOS
   */
  public void setDeliveryQos(BMXMessage.DeliveryQos qos) {
    flooJNI.BMXMessage_setDeliveryQos(swigCPtr, this, qos.swigValue());
  }

  /**
   *  消息发送者的显示名称
   * @return std::string
   */
  public String senderName() {
    return flooJNI.BMXMessage_senderName(swigCPtr, this);
  }

  /**
   *  设置消息的发送者显示名称
   * @param senderName 消息文本内容
   */
  public void setSenderName(String senderName) {
    flooJNI.BMXMessage_setSenderName(swigCPtr, this, senderName);
  }

  /**
   *  群消息已读AckCount数目
   * @return int
   */
  public int groupAckCount() {
    return flooJNI.BMXMessage_groupAckCount(swigCPtr, this);
  }

  /**
   *  群消息未读AckCount数目
   * @return int
   */
  public int groupAckUnreadCount() {
    return flooJNI.BMXMessage_groupAckUnreadCount(swigCPtr, this);
  }

  /**
   *  群消息是否全部已读
   * @return bool
   */
  public boolean groupAckReadAll() {
    return flooJNI.BMXMessage_groupAckReadAll(swigCPtr, this);
  }

  /**
   *  获取群消息已播放计数
   * @return bool
   */
  public int groupPlayAckCount() {
    return flooJNI.BMXMessage_groupPlayAckCount(swigCPtr, this);
  }

  public void setGroupPlayAckCount(int count) {
    flooJNI.BMXMessage_setGroupPlayAckCount(swigCPtr, this, count);
  }

  /**
   *  获取群消息已播放回执未读计数
   * @return bool
   */
  public int groupPlayAckUnreadCount() {
    return flooJNI.BMXMessage_groupPlayAckUnreadCount(swigCPtr, this);
  }

  public void setGroupPlayAckUnreadCount(int count) {
    flooJNI.BMXMessage_setGroupPlayAckUnreadCount(swigCPtr, this, count);
  }

  /**
   *  设置所有群消息已播回执为已读
   * @return bool
   */
  public boolean groupPlayAckReadAll() {
    return flooJNI.BMXMessage_groupPlayAckReadAll(swigCPtr, this);
  }

  /**
   * 设置消息的扩散优先级，默认为0。0表示扩散，数字越小扩散的越多。
   * 取值范围0-10。普通人在聊天室发送的消息级别默认为5，可以丢弃。管理员默认为0不会丢弃。其它值可以根据业务自行设置。
   * @param priority 优先级
   */
  public void setPriority(int priority) {
    flooJNI.BMXMessage_setPriority(swigCPtr, this, priority);
  }

  /**
   * 消息的扩散优先级
   * @return int
   */
  public int priority() {
    return flooJNI.BMXMessage_priority(swigCPtr, this);
  }


  /**
   * 设置是否推送消息
   */
  public void setPushMessageMode(boolean arg0) {
    flooJNI.BMXMessage_setPushMessageMode(swigCPtr, this, arg0);
  }

  /**
   * 是否是推送消息
   * @return boolean
   */
  public boolean isPushMessage() {
    return flooJNI.BMXMessage_isPushMessage(swigCPtr, this);
  }


  /**
   *  创建发送文本消息
   * @param from 消息发送者
   * @param to 消息接收者
   * @param type 消息类型
   * @param conversationId 会话id
   * @param content 消息内容
   **/
  public static BMXMessage createMessage(long from, long to, BMXMessage.MessageType type, long conversationId, String content) {
    long cPtr = flooJNI.BMXMessage_createMessage__SWIG_0(from, to, type.swigValue(), conversationId, content);
    return (cPtr == 0) ? null : new BMXMessage(cPtr, true);
  }

  /**
   *  创建发送附件消息
   * @param from 消息发送者
   * @param to 消息接收者
   * @param type 消息类型
   * @param conversationId 会话id
   * @param attachment 附件
   **/
  public static BMXMessage createMessage(long from, long to, BMXMessage.MessageType type, long conversationId, BMXMessageAttachment attachment) {
    long cPtr = flooJNI.BMXMessage_createMessage__SWIG_1(from, to, type.swigValue(), conversationId, BMXMessageAttachment.getCPtr(attachment), attachment);
    return (cPtr == 0) ? null : new BMXMessage(cPtr, true);
  }

  /**
   *  创建发送命令消息(命令消息通过content字段或者extension字段存放命令信息)
   * @param from 消息发送者
   * @param to 消息接收者
   * @param type 消息类型
   * @param conversationId 会话id
   * @param content 消息内容
   **/
  public static BMXMessage createCommandMessage(long from, long to, BMXMessage.MessageType type, long conversationId, String content) {
    long cPtr = flooJNI.BMXMessage_createCommandMessage__SWIG_0(from, to, type.swigValue(), conversationId, content);
    return (cPtr == 0) ? null : new BMXMessage(cPtr, true);
  }

  /**
   *  创建RTC的消息
   * @param from 消息发送者
   * @param to 消息接收者
   * @param type 消息类型
   * @param conversationId 会话id
   * @param content 消息内容
   **/
  public static BMXMessage createRTCMessage(long from, long to, BMXMessage.MessageType type, long conversationId, String content) {
    long cPtr = flooJNI.BMXMessage_createRTCMessage__SWIG_0(from, to, type.swigValue(), conversationId, content);
    return (cPtr == 0) ? null : new BMXMessage(cPtr, true);
  }

  /**
   *  创建收到的消息
   * @param msgId 消息id
   * @param from 消息发送者
   * @param to 消息接收者
   * @param type 消息类型
   * @param conversationId 会话id
   * @param content 消息内容
   * @param serverTimestamp 服务器时间戳
   **/
  public static BMXMessage createMessage(long msgId, long from, long to, BMXMessage.MessageType type, long conversationId, String content, long serverTimestamp) {
    long cPtr = flooJNI.BMXMessage_createMessage__SWIG_2(msgId, from, to, type.swigValue(), conversationId, content, serverTimestamp);
    return (cPtr == 0) ? null : new BMXMessage(cPtr, true);
  }


  /**
   *  创建收到的RTC消息
   * @param msgId 消息id
   * @param from 消息发送者
   * @param to 消息接收者
   * @param type 消息类型
   * @param conversationId 会话id
   * @param content 消息内容
   * @param serverTimestamp 服务器时间戳
   **/
  public static BMXMessage createRTCMessage(long msgId, long from, long to, BMXMessage.MessageType type, long conversationId, String content, long serverTimestamp) {
    long cPtr = flooJNI.BMXMessage_createRTCMessage__SWIG_1(msgId, from, to, type.swigValue(), conversationId, content, serverTimestamp);
    return (cPtr == 0) ? null : new BMXMessage(cPtr, true);
  }

  /**
   *  创建收到的消息
   * @param msgId 消息id
   * @param from 消息发送者
   * @param to 消息接收者
   * @param type 消息类型
   * @param conversationId 会话id
   * @param attachment 附件
   * @param serverTimestamp 服务器时间戳
   **/
  public static BMXMessage createMessage(long msgId, long from, long to, BMXMessage.MessageType type, long conversationId, BMXMessageAttachment attachment, long serverTimestamp) {
    long cPtr = flooJNI.BMXMessage_createMessage__SWIG_3(msgId, from, to, type.swigValue(), conversationId, BMXMessageAttachment.getCPtr(attachment), attachment, serverTimestamp);
    return (cPtr == 0) ? null : new BMXMessage(cPtr, true);
  }

  /**
   *  创建收到的命令消息(命令消息通过content字段或者extension字段存放命令信息)
   * @param msgId 消息id
   * @param from 消息发送者
   * @param to 消息接收者
   * @param type 消息类型
   * @param conversationId 会话id
   * @param content 消息内容
   * @param serverTimestamp 服务器时间戳
   **/
  public static BMXMessage createCommandMessage(long msgId, long from, long to, BMXMessage.MessageType type, long conversationId, String content, long serverTimestamp) {
    long cPtr = flooJNI.BMXMessage_createCommandMessage__SWIG_1(msgId, from, to, type.swigValue(), conversationId, content, serverTimestamp);
    return (cPtr == 0) ? null : new BMXMessage(cPtr, true);
  }

  /**
   *  创建转发消息
   * @param msg 要转发的消息
   * @param from 消息发送者
   * @param to 消息接收者
   * @param type 消息类型
   * @param conversationId 会话id
   **/
  public static BMXMessage createForwardMessage(BMXMessage msg, long from, long to, BMXMessage.MessageType type, long conversationId) {
    long cPtr = flooJNI.BMXMessage_createForwardMessage(BMXMessage.getCPtr(msg), msg, from, to, type.swigValue(), conversationId);
    return (cPtr == 0) ? null : new BMXMessage(cPtr, true);
  }

  /**
   *   消息投递状态
   **/
  public enum DeliveryStatus {
    New,
    Delivering,
    Deliveried,
    Failed,
    Recalled;

    public final int swigValue() {
      return swigValue;
    }

    public static DeliveryStatus swigToEnum(int swigValue) {
      DeliveryStatus[] swigValues = DeliveryStatus.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (DeliveryStatus swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + DeliveryStatus.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private DeliveryStatus() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private DeliveryStatus(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private DeliveryStatus(DeliveryStatus swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  /**
   *   消息类型
   **/
  public enum MessageType {
    Single,
    Group,
    System;

    public final int swigValue() {
      return swigValue;
    }

    public static MessageType swigToEnum(int swigValue) {
      MessageType[] swigValues = MessageType.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (MessageType swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + MessageType.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private MessageType() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private MessageType(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private MessageType(MessageType swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  /**
   *   消息内容类型
   **/
  public enum ContentType {
    Text,
    Image,
    Voice,
    Video,
    File,
    Location,
    Command,
    Forward,
    RTC;

    public final int swigValue() {
      return swigValue;
    }

    public static ContentType swigToEnum(int swigValue) {
      ContentType[] swigValues = ContentType.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (ContentType swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + ContentType.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private ContentType() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private ContentType(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private ContentType(ContentType swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

  /**
   *   消息投递质量
   **/
  public enum DeliveryQos {
    AtLastOnce,
    AtMostOnce,
    ExactlyOnce;

    public final int swigValue() {
      return swigValue;
    }

    public static DeliveryQos swigToEnum(int swigValue) {
      DeliveryQos[] swigValues = DeliveryQos.class.getEnumConstants();
      if (swigValue < swigValues.length && swigValue >= 0 && swigValues[swigValue].swigValue == swigValue)
        return swigValues[swigValue];
      for (DeliveryQos swigEnum : swigValues)
        if (swigEnum.swigValue == swigValue)
          return swigEnum;
      throw new IllegalArgumentException("No enum " + DeliveryQos.class + " with value " + swigValue);
    }

    @SuppressWarnings("unused")
    private DeliveryQos() {
      this.swigValue = SwigNext.next++;
    }

    @SuppressWarnings("unused")
    private DeliveryQos(int swigValue) {
      this.swigValue = swigValue;
      SwigNext.next = swigValue+1;
    }

    @SuppressWarnings("unused")
    private DeliveryQos(DeliveryQos swigEnum) {
      this.swigValue = swigEnum.swigValue;
      SwigNext.next = this.swigValue+1;
    }

    private final int swigValue;

    private static class SwigNext {
      private static int next = 0;
    }
  }

}
